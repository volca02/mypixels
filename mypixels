#!/usr/bin/env python2
""" mypixels - A low clutter, python-gtk based terminal emulator.
"""

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Glued together in free time by Filip Volejnik: f.volejnik at google mail
# heavily inspired by uzbl-tabbed.py
# Solarized colors are a great piece of work of Ethan Schoonover
# TODO: Timer for tablist updates - optionally set to refresh if using some dynamic status
# TODO: Write to buffer - a small box floating somewhere that'll display what user's writing (in parallel with the console).
# TODO: Tagging of consoles - and grouping via those tags (partially done with tab coloring)

import gi
from gi import pygtkcompat
gi.require_version('Vte', '2.91')
pygtkcompat.enable()
pygtkcompat.enable_gtk(version='3.0')
import gtk
import gobject
from gi.repository import Vte, GLib, Gdk
#import vte
import pango
import types
import yaml
import os.path
import sys
import cgi

def clock():
    from time import localtime, strftime
    return "<span foreground = '#966'>%s</span> " % strftime("%H:%M", localtime())

callables = {
    'clock' : clock
    }

max_groups = 8

# Default config
config = {
    'tablist_background': "#303030", # Tablist background
    'multiline_tabs': True,
    'focus_new_tabs': True,
    'tab_prepend': 'clock', # name of callback function that generates pango markup text appended to tab list before the tabs
    'tab_append': None,  # the same, but appended after tab list
    'tab_format': '<span %(color)s>[%(entangled)s%(tname)s]</span>', # tid Tab id (unique), tname - tab name, tidx - tab index (from 1 on the left)
    'tab_color_bg': '#303030',
    'tab_color_bg_selected': '#505020',
    'tab_color_fg': '#888',
    'tab_color_fg_selected': '#fff',
    'tab_color_entangle': '#f00',
    'tablist_font': 'Liberation Mono 7',
    'term_font': 'Terminus 8',
    'default_tab_title': '',
    'scrollback_lines': 1000,
    'term_opacity': 0.1,
    'bg_tint_color': '#140008',
    'foreground_color': '#BBB',
    'background_color': '#000',
    'hide_single_tab': False,
    'tablist_top': True,
    'tab_title_max_length': 16, # -1 to disable this
    'tab_title_short_current': 32, # shorten the selected tab title (False - don't, True - do, int > 0 current title max length)
    'tab_title_shorten_start': False, # shorten so that end of the text is visible, not start
    'tablist_hide': False,
    'default_width': 640,
    'default_height': 480,

    'palette': '',

    # choosable tab colors (grouping)
    'col_0': '#b58900',
    'col_1': '#cb4b16',
    'col_2': '#dc322f',
    'col_3': '#d33682',
    'col_4': '#6c71c4',
    'col_5': '#268bd2',
    'col_6': '#2aa198',
    'col_7': '#859900',

    'bindings': {
        'move_prev_tab' : 'MOD1+SHIFT+Left',
        'move_next_tab' : 'MOD1+SHIFT+Right',
        'move_first_tab': 'MOD1+SHIFT+Home',
        'move_last_tab' : 'MOD1+SHIFT+End',

        'prev_tab': ('MOD1+Left', 'MOD1+SHIFT+f'),
        'next_tab': ('MOD1+Right', 'MOD1+SHIFT+b'),
        'first_tab': 'MOD1+Home',
        'last_tab': 'MOD1+End',

        'close_tab': ('CONTROL+ALT+x', 'CONTROL+ALT+q'),
        'new_tab': ('CONTROL+ALT+z', 'CONTROL+SHIFT+t'),

        'shrink_font': 'MOD1+SHIFT+KP_Subtract',
        'enlarge_font': 'MOD1+SHIFT+KP_Add',

        'toggle_hide_tabs': 'CONTROL+SHIFT+v',

        'prev_color': 'MOD1+SHIFT+braceleft',
        'next_color': 'MOD1+SHIFT+braceright',

        'toggle_entangle': 'MOD1+SHIFT+KP_Multiply',

        'rename_tab': 'MOD1+SHIFT+n',

        'show_search': 'MOD1+SHIFT+s',

        'search_prev': 'MOD1+SHIFT+a',
        'search_next': 'MOD1+SHIFT+d',

        'goto_tab_0': 'MOD1+_1',
        'goto_tab_1': 'MOD1+_2',
        'goto_tab_2': 'MOD1+_3',
        'goto_tab_3': 'MOD1+_4',
        'goto_tab_4': 'MOD1+_5',
        'goto_tab_5': 'MOD1+_6',
        'goto_tab_6': 'MOD1+_7',
        'goto_tab_7': 'MOD1+_8',
        'goto_tab_8': 'MOD1+_9',
        'goto_tab_9': 'MOD1+_0'
    }
};

# Used for quick selection via <Mod1>[0-9]
num2key = (
    gtk.keysyms._1,
    gtk.keysyms._2,
    gtk.keysyms._3,
    gtk.keysyms._4,
    gtk.keysyms._5,
    gtk.keysyms._6,
    gtk.keysyms._7,
    gtk.keysyms._8,
    gtk.keysyms._9,
    gtk.keysyms._0,
    );

str2mod = {
    'mod1':  gtk.gdk.MOD1_MASK,
    'alt':  gtk.gdk.MOD1_MASK,
    'shift': gtk.gdk.SHIFT_MASK,
    'control': gtk.gdk.CONTROL_MASK,
    'ctrl': gtk.gdk.CONTROL_MASK
}

# parses mod+mod+key
def key_press_parse(bindstr):
    key = None
    mods = 0

    for kp in bindstr.split('+'):
        kl = kp.lower()
        if kl in str2mod:
            mods = mods | str2mod[kl]
        else:
            if not key:
                key = dict(gtk.keysyms.__dict__)[kp]
            else:
                print("Parse error: '%s' - part '%s', state %s, %s" % (bindstr, kp, str(key), str(mods)))

    return (mods, key)

def parse_rgba(color):
    col = gtk.gdk.RGBA()
    col.parse(color)
    return col


# parses key_combo=call(arg)
def key_bind_parse(bindstr):
    pass

# stolen from Terminator https://github.com/m45t3r/t3rminator/blob/master/terminatorlib/terminator.py
def eventkey2gdkevent(eventkey):  # FIXME FOR GTK3: is there a simpler way of casting from specific EventKey to generic (union) GdkEvent?
    gdkevent = Gdk.Event(eventkey.type)
    gdkevent.key.type = eventkey.type
    gdkevent.key.window = eventkey.window
    gdkevent.key.send_event = eventkey.send_event
    gdkevent.key.time = eventkey.time
    gdkevent.key.state = eventkey.state
    gdkevent.key.keyval = eventkey.keyval
    gdkevent.key.length = eventkey.length
    gdkevent.key.string = eventkey.string
    gdkevent.key.hardware_keycode = eventkey.hardware_keycode
    gdkevent.key.group = eventkey.group
    gdkevent.key.is_modifier = eventkey.is_modifier
    return gdkevent

def counter():
    """ Tab ID generator """
    i = 1
    while True:
        yield i
        i += 1

def dialog_get_text(parent, message, default=''):
    """
    Display a dialog with a text entry.
    Returns the text, or None if canceled.
    """
    d = gtk.MessageDialog(parent,
                          gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                          gtk.MESSAGE_QUESTION,
                          gtk.BUTTONS_OK_CANCEL,
                          message)
    entry = gtk.Entry()
    entry.set_text(default)
    entry.show()
    d.vbox.pack_end(entry)
    entry.connect('activate', lambda _: d.response(gtk.RESPONSE_OK))
    d.set_default_response(gtk.RESPONSE_OK)

    r = d.run()
    text = entry.get_text().decode('utf8')
    d.destroy()
    if r == gtk.RESPONSE_OK:
        return text
    else:
        return None

class MyPixels:
    def __init__(self):
        # counter used for tab id's
        self.counter = counter()

        # entangled terms for multi term keyboard events
        self.entangled = []

        # create a window to hold the thing
        self.window = gtk.Window()
        self.window.set_title("mypixels")
        self.window.set_border_width(0)

        self.window.connect("delete-event", self.quit_request)

        self.keybinds = []
        self.keymap = {}

        # default font size - zero is ignored
        self.fontsize = 0

        # handle config
        try:
            with open(os.path.expanduser("~/.mypixels")) as f:
                myconfig = yaml.load(f)

            try:
                for k in config.keys():
                    # if this is a keymap, descend
                    if k == "bindings":
                        if "bindings" in myconfig:
                            for fn, b in myconfig['bindings'].items():
                                config[k][fn] = b
                    else:
                        if k in myconfig:
                            config[k] = myconfig[k]
            except Exception as e:
                print("Config parse error: " % str(e))
                pass
        except:
            pass
            # if no config is found, write the default mappings into the config
            #self.write_config()

        # parse the config key bindings
        self.set_funcmap()
        self.keymap = config['bindings']
        self.transform_keybinds()

        # convert the call config vars to callables
        if 'palette' in config:
            colors = config['palette'].split(':')
            self.palette = []
            for color in colors:
                if color:
                    self.palette.append(parse_rgba(color))
        else:
            self.palette = None

        self.fg_color = parse_rgba(config['foreground_color'])
        self.bg_color = parse_rgba(config['background_color'])

        self.overlay = gtk.Overlay()
        self.window.add(self.overlay)
        self.overlay.show()

        vbox = gtk.VBox()
        self.vbox = vbox
        self.vbox.set_resize_mode(gtk.RESIZE_IMMEDIATE)
        self.overlay.add(vbox)

        ebox = gtk.EventBox()
        self.ebox = ebox

        self.tablist = gtk.Label()

        fontdesc = pango.FontDescription(config["tablist_font"])
        self.tablist.modify_font(fontdesc)
        self.tablist.set_use_markup(True)
        self.tablist.set_justify(gtk.JUSTIFY_LEFT)
        self.tablist.set_line_wrap(False)
        self.tablist.set_selectable(False)
        self.tablist.set_padding(2,2)
        self.tablist.set_alignment(0,0)
        self.tablist.set_ellipsize(pango.ELLIPSIZE_END)
        self.tablist.set_text(" ")
        self.tablist.show()

        ebox.add(self.tablist)
        ebox.show()
        bgcolor = gtk.gdk.color_parse(config['tablist_background'])
        ebox.modify_bg(gtk.STATE_NORMAL, bgcolor)

        # gtk notebook that holds the vterms
        self.notebook = gtk.Notebook()
        self.notebook.set_show_tabs(False)

        self.notebook.set_show_border(False)
        self.notebook.set_scrollable(True)
        self.notebook.set_border_width(0)

        self.notebook.connect("page-removed", self.tab_closed)
        self.notebook.connect("switch-page", self.tab_changed)
        self.notebook.connect("page-added", self.tab_opened)
        self.notebook.connect("page-reordered", self.tab_reordered)

        vbox.pack_start(self.notebook, True, True, 0)
        vbox.pack_start(self.ebox, False, False, 0)

        if config["tablist_top"]:
            vbox.reorder_child(self.ebox, 0)
            vbox.reorder_child(self.notebook, 1)
        else:
            vbox.reorder_child(self.notebook, 1)
            vbox.reorder_child(self.ebox, 2)

        self.notebook.show()

        self.window.connect("key-press-event", self.key_pressed)
        self.window.connect("key-release-event", self.key_released)
        self.window.connect("configure-event", self.resize_request)

        # window fixup before we create tab
        self.window.resize(config["default_width"], config["default_height"])

        # searchbox, if it updates, we update the vtk search
        self.search_entry = gtk.Entry()

        self.search_entry.set_margin_start(5);
        self.search_entry.set_margin_end(5);
        self.search_entry.set_margin_top(5);
        self.search_entry.set_margin_bottom(5);
        self.search_entry.set_halign(gtk.ALIGN_START);
        self.search_entry.set_valign(gtk.ALIGN_END);
        self.search_entry.connect("key-press-event", self.search_key_pressed)
        self.search_entry.connect("focus-out-event", self.search_lose_focus)

        self.overlay.add_overlay(self.search_entry)

        self.vbox.show()
        self.window.show()

        self.notebook.grab_focus()

        self.forcedHideTabs = config['tablist_hide']

        self.tabs = {}

    def transform_keybinds(self):
        # transforms self.keymap ("function->binds") to self.keybinds
        for fn, bind in self.keymap.items():
            func = self.funcmap[fn]
            if isinstance(bind, list) or isinstance(bind, tuple):
                for b in bind:
                   (mods, key) = key_press_parse(b)
                   self.keybinds.append((key, mods, func[0], func[1]))
            else:
                (mods, key) = key_press_parse(bind)
                self.keybinds.append((key, mods, func[0], func[1]))

    def set_funcmap(self):
        self.funcmap = {
            'move_prev_tab':  (self.move_prev_tab, None),
            'move_next_tab':  (self.move_next_tab, None),
            'move_first_tab': (self.move_prev_tab, -1),
            'move_last_tab':  (self.move_next_tab, -1),

            'prev_tab': (self.prev_tab, None),
            'next_tab': (self.next_tab, None),
            'first_tab': (self.prev_tab, -1),
            'last_tab': (self.next_tab, -1),

            'close_tab': (self.close_tab, None),
            'new_tab': (self.new_tab, None),

            'shrink_font': (self.shrink_font, None),
            'enlarge_font': (self.enlarge_font, None),

            'toggle_hide_tabs': (self.toggle_hide_tabs, None),

            'prev_color': (self.switch_group, -1),
            'next_color': (self.switch_group,  1),

            'toggle_entangle': (self.toggle_entangle, None),

            'rename_tab': (self.rename_tab, None),

            'show_search': (self.show_search, None),

            'search_prev': (self.search_advance, False),
            'search_next': (self.search_advance, True)
        }

        for i in range(0, 10):
            self.funcmap['goto_tab_' + str(i)] = (self.goto_tab, i);

    def write_config(self):
        with open(os.path.expanduser('~/.mypixels'), 'w') as f:
            yaml.dump(config, f, default_flow_style=False)

    def resize_request(self, wnd, event):
        self.update_tablist()

    def key_pressed(self, wnd, event):
        if event.type == gtk.gdk.KEY_PRESS:
            # skim through the bindings
            mods = event.state & gtk.accelerator_get_default_mod_mask()
            keyval = gtk.gdk.keyval_to_lower(event.keyval)

            # TODO: Could accelerate this by placing the key combination into a dict
            for bind in self.keybinds:
                if (bind[0] == keyval) and (bind[1] == mods):
                    bind[2](bind[3])
                    return True

        # tangled terminals? if so, propagate
        tabn = self.notebook.get_current_page()
        tab = self.notebook.get_nth_page(tabn)

        if (tab in self.entangled):
            for term in self.entangled:
                term.emit("key-press-event", eventkey2gdkevent(event))
            return True

        return False

    def key_released(self, wnd, event):
        tabn = self.notebook.get_current_page()
        tab = self.notebook.get_nth_page(tabn)

        if (tab in self.entangled):
            for term in self.entangled:
                term.emit("key-release-event", eventkey2gdkevent(event))
            return True
        return False

    def enlarge_font(self, param):
        self.zoom(True)

    def shrink_font(self, param):
        self.zoom(False)

    def zoom(self, zoom):
        for idx, tab in enumerate(self.notebook):
            pangodesc = tab.get_font()
            fontsize = pangodesc.get_size()

            if fontsize > pango.SCALE and not zoom:
                fontsize -= pango.SCALE
            elif zoom:
                fontsize += pango.SCALE

            pangodesc.set_size(fontsize)
            self.fontsize=fontsize
            tab.set_font(pangodesc)


    def new_tab(self, command=None, tnext=False, title="", cmd=None):
        # new tab instance
        tab = Vte.Terminal()
        tab.connect("child-exited", self.child_exited)
        tab.connect("eof", self.child_eof)
        tab.connect("window-title-changed", self.window_title_changed)
#        tab.connect("key-press-event", self.key_pressed)
#        tab.connect("key-release-event", self.key_released)

        tab.set_font(pango.FontDescription(config["term_font"]))
        tab.set_scrollback_lines(config['scrollback_lines'])
        tab.search_set_wrap_around(True)

        tab.set_word_char_exceptions("-A-Za-z0-9,./?%&#:_~")
        bg_color = Gdk.RGBA()
        bg_color.parse(config['bg_tint_color'])
        bg_color.alpha=1.0-config['term_opacity']
        tab.set_color_background(bg_color)

        if self.palette:
            tab.set_colors(self.fg_color, self.bg_color, self.palette)

        tid = self.counter.next()

        if self.fontsize:
            pangodesc = tab.get_font()
            pangodesc.set_size(self.fontsize)
            tab.set_font(pangodesc)

        # The empty argv list is a fix for zsh segv...
        command=[Vte.get_user_shell()]
        if (cmd):
            command = cmd
        elif (self.command):
            command=self.command

        tab.spawn_sync(
            Vte.PtyFlags.DEFAULT,
            os.environ['HOME'],
            command,
            [],
            0,
            None,
            None,
            None
        )

        tab.show()

#        if (command):
#            tab.feed_child(command)

        self.notebook.insert_page(tab, None, tnext and self.notebook.get_current_page() + 1 or -1)
        self.notebook.set_tab_reorderable(tab, True)

        if not title:
            title = config["default_tab_title"]

        self.tabs[tab] = {"title": title, "id": tid}
        self.update_tablist()

        tab.grab_focus()

    def update_tablist(self):
        if (self.notebook.get_n_pages() <= 1 and config["hide_single_tab"]) \
            or self.forcedHideTabs:
            self.tablist.hide()
            return

        # TODO: refit the window
        self.tablist.show()

        multiline_tabs = config['multiline_tabs']

        multiline = []
        pango = ""

        if config['tab_prepend']:
            pango = callables[config['tab_prepend']]()

        curidx = self.notebook.get_current_page()

        tab_format = config['tab_format']
        max_title_len = config['tab_title_max_length']

        for idx, tab in enumerate(self.notebook):
            colfg = config["tab_color_fg"]
            colbg = config["tab_color_bg"]

            tidx = idx + 1
            tid = tidx
            tname = ""

            if tab in self.tabs:
                params = self.tabs[tab]
                tid = params["id"]
                tname = params["title"]
                if "name" in params:
                    tname = params["name"]

            if not tname:
                tname = str(tid)

            if (idx != curidx):
                if max_title_len > 0 and len(tname) > max_title_len:
                    if config['tab_title_shorten_start']:
                        tname = "\xe2\x80\xa6" + tname[len(tname)-max_title_len:]
                    else:
                        tname = tname[:max_title_len] + "\xe2\x80\xa6"
            else:
                colfg = config["tab_color_fg_selected"]
                colbg = config["tab_color_bg_selected"]

                cname = '_selected'
                mt_cur = max_title_len
                sh_cur = config['tab_title_short_current']

                if (type(sh_cur) == types.IntType):
                    mt_cur = sh_cur
                    sh_cur = True

                if sh_cur and mt_cur > 0 and len(tname) > mt_cur:
                   if config['tab_title_shorten_start']:
                       tname = "\xe2\x80\xa6" + tname[len(tname) - mt_cur:]
                   else:
                       tname = tname[:mt_cur] + "\xe2\x80\xa6"

            # now if we have group set for the tab, override
            if tab in self.tabs:
                grp = self.tabs[tab].get("group", None)
            else:
                grp = None

            if tab in self.entangled:
                entangled = "<span foreground=\"%s\">*</span>" % (config["tab_color_entangle"])
            else:
                entangled = ""

            if grp:
                colfg = config["col_%d" % grp]

            color = "foreground=\"%s\" background=\"%s\"" % (colfg, colbg)

            # fixup title - dangerous chars
            tname = cgi.escape(tname)

            if multiline_tabs:
                opango = pango

                pango += tab_format % locals()

                self.tablist.set_markup(pango)
                listwidth = self.tablist.get_layout().get_pixel_size()[0]
                winwidth = self.window.get_size()[0]

                if listwidth > (winwidth - 20):
                    if opango != "":
                        multiline.append(opango)

                    pango = tab_format % locals()
            else:
                pango += tab_format % locals()

        if (config['tab_append']):
            pango += " " + callables[config['tab_append']]()

        if multiline_tabs:
            multiline.append(pango)
            self.tablist.set_markup('&#10;'.join(multiline))
        else:
            self.tablist.set_markup(pango)


    def next_tab(self, skip=1, move=False):
        """ Focuses next tab. If skip is negative, focuses last tab.
        If move is true, moves the tab to the place (otherwise it just focuses)
        """
        if not skip:
            skip = 1

        ntabs = self.notebook.get_n_pages()

        if (ntabs <= 0):
            return

        if skip < 0:
            tabn = ntabs - 1
        else:
            tabn = (self.notebook.get_current_page() + skip) % ntabs

        self.goto_tab(tabn, move)

    def prev_tab(self, skip=1, move=False):
        """ Focuses previous tab. If skip is negative, focuses first tab.
        If move is true, moves the tab to the place (otherwise it just focuses)
        """
        if not skip:
            skip = 1

        ntabs = self.notebook.get_n_pages()

        if (ntabs <= 0):
            return

        if skip < 0:
            tabn = 0
        else:
            tabn = (self.notebook.get_current_page() - skip) % ntabs

        while (tabn < 0):
            tabn += ntabs

        self.goto_tab(tabn, move)

    def move_next_tab(self, skip=1):
        """ Like next_tab, but moves the current tab to the place """
        self.next_tab(skip, move=True)

    def move_prev_tab(self, skip=1):
        """ Like next_tab, but moves the current tab to the place """
        self.prev_tab(skip, move=True)

    def move_first_tab(self, arg=None):
        self.prev_tab(-1, move=True)

    def move_last_tab(self, arg=None):
        self.next_tab(-1, move=True)

    def goto_tab(self, tabn, move=False):
        if move:
            idx = self.notebook.get_current_page()
            tab = self.notebook.get_nth_page(idx)
            self.notebook.reorder_child(tab, tabn)

        self.notebook.set_current_page(tabn)
        self.update_tablist()

    def toggle_entangle(self, ignored):
        tab = self.get_current_tab()

        if tab in self.entangled:
            self.entangled = filter(lambda t: t != tab, self.entangled)
        else:
            self.entangled.append(tab)

        self.update_tablist()

    def toggle_hide_tabs(self, tabn=None):
        self.forcedHideTabs = not self.forcedHideTabs
        self.update_tablist()

    def close_tab(self, tabn=None):
        # TODO: What if this ended when not a current page?
        if not tabn:
            tabn = self.notebook.get_current_page()

        if (tabn >= 0):
            self.notebook.remove_page(tabn)

        if (self.notebook.get_n_pages() <= 0):
            self.quit_request()
        else:
            tabn = self.notebook.get_current_page()
            # refocus
            self.notebook.set_current_page(tabn)

        self.update_tablist()

    def rename_tab(self, tabn=None):
        if not tabn:
            tabn = self.notebook.get_current_page()

        tab = self.notebook.get_nth_page(tabn)
        name = dialog_get_text(
            self.window, "Tab name", self.tabs[tab].get('name', ''))
        if name:
            self.tabs[tab]['name'] = name
            self.update_tablist()

    def tab_closed(self, notebook, tab, index):
        del self.tabs[tab]

    def child_exited(self, a=None, b=None):
        self.close_tab()

    def child_eof(self, a=None, b=None):
        pass

    def window_title_changed(self, term):
        self.tabs[term]['title'] = term.get_window_title()
        self.update_tablist()

    def tab_opened(self, notebook, tab, index):
        if config["focus_new_tabs"]:
            self.notebook.set_focus_child(tab)
            self.notebook.set_current_page(index)
        else:
            oldindex = self.notebook.get_current_page()

            if oldindex < 0:
                oldindex = index

            oldtab = self.notebook.get_nth_page(oldindex)
            self.notebook.set_focus_child(oldtab)
            self.notebook.set_current_page(oldindex)

    def tab_changed(self, notebook, tab, index):
        self.update_tablist()

    def tab_reordered(self, notebook, tab, index):
        self.update_tablist()

    def switch_group(self, skip):
        tabn = self.notebook.get_current_page()
        tab = self.notebook.get_nth_page(tabn)

        params = self.tabs.setdefault(tab, {})

        grp = params.setdefault("group", 0) + skip

        # if the group goes beyond 0 or max
        if grp < 0:
            grp = max_groups - 1

        if grp >= max_groups:
            grp = 0

        # if the group is zero, remove the def
        # otherwise replace
        if grp == 0:
            del params["group"]
        else:
            params["group"] = grp

        # update tab view
        self.update_tablist()

    def show_search(self, param=None):
        self.search_entry.show()
        self.search_entry.grab_focus()

    def hide_search(self, param=None):
        self.search_entry.hide()

    def search_advance(self, forward=True):
        tab = self.get_current_tab()
        if (forward):
            tab.search_find_next()
        else:
            tab.search_find_previous()

    def get_current_tab(self):
        tabn = self.notebook.get_current_page()
        return self.notebook.get_nth_page(tabn)

    def search_lose_focus(self, wnd, event):
        self.hide_search()
        # re-focus current tab
        self.get_current_tab().grab_focus()

    def search_key_pressed(self, wnd, event):
        if event.type == gtk.gdk.KEY_PRESS:
            if (event.keyval == gtk.keysyms.Escape):
                self.hide_search()
                return False
            if (event.keyval == gtk.keysyms.Return):
                self.update_search_term(self.search_entry.get_text())
                self.hide_search()
                self.search_advance(True)
                return False
        return False

    def update_search_term(self, text):
        tab = self.get_current_tab()
        regex = GLib.Regex(text, 0, 0)
        tab.search_set_gregex(regex, 0)

    def run(self):
        # first initial tab
        self.command = None

        # is there any command on the cmdline?
        if (len(sys.argv) > 1):
                self.command=sys.argv[1:]

        self.new_tab()
        gtk.main()

    def quit_request(self, *args):
        # if there is more than one tab, ask
        if (self.notebook.get_n_pages() > 1):
            # ask first
            dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL, \
                gtk.MESSAGE_INFO, gtk.BUTTONS_YES_NO, "Do you really want to close?")

            rv = dialog.run()
            dialog.destroy()

            if rv != gtk.RESPONSE_YES:
                return True # cancel the quit

        # TODO: Cleanup
        gtk.main_quit()

if __name__ == '__main__':
    term = MyPixels()
    term.run()
